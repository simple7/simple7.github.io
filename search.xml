<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[js之深浅拷贝]]></title>
      <url>/2017/08/01/js%E4%B9%8B%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      <content type="html"><![CDATA[<blockquote>
<p>2017.08.01 星期二 晴 又踏上了一段新的旅途，不知前路如何，总觉得过好当下吧！</p>
</blockquote>
<p>前段时间面试遇到一个我觉得有必要深入了解的问题，关于js浅拷贝和深拷贝的问题</p>
<h3 id="js的变量类型"><a href="#js的变量类型" class="headerlink" title="js的变量类型"></a>js的变量类型</h3><h4 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1. 基本类型"></a>1. 基本类型</h4><p>Undefined、Null、Boolean、Number和String五种基本数据类型的变量是按值存放的，存放在栈内存中的简单数据段</p>
<h4 id="2-引用类型"><a href="#2-引用类型" class="headerlink" title="2.  引用类型"></a>2.  引用类型</h4><p>存放在堆内存中的对象，变量保存的是一个指针，指针指向另一个位置。如数组、对象。</p>
<h3 id="浅拷贝的实现"><a href="#浅拷贝的实现" class="headerlink" title="浅拷贝的实现"></a>浅拷贝的实现</h3><p>对于基本类型，直接引用赋值即是深拷贝，而对于引用类型则是浅拷贝，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function shallowClone(copyObj) &#123;</div><div class="line"> var obj = &#123;&#125;;</div><div class="line"> for ( var i in copyObj) &#123;</div><div class="line"> obj[i] = copyObj[i];</div><div class="line"> &#125;</div><div class="line"> return obj;</div><div class="line">&#125;</div><div class="line">var x = &#123;</div><div class="line"> a: 1,</div><div class="line"> b: &#123; f: &#123; g: 1 &#125; &#125;,</div><div class="line"> c: [ 1, 2, 3 ]</div><div class="line">&#125;;</div><div class="line">var y = shallowClone(x);</div><div class="line">console.log(y.b.f === x.b.f);  // true</div></pre></td></tr></table></figure>
<p>上述结果表示对象直接赋值实际上是赋给新对象一个指针指向原来的对象，那么关于引用类型的深复制如何实现呢？</p>
<h3 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a>深拷贝的实现</h3><p>在上一篇博文中刚好写了callee和caller，本来我还觉得这俩货无用武之地，现在看来是自己肤浅了。在使用递归的时候callee还是很好用的，例如实现一个深拷贝：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function deepClone(initalObj, finalObj) &#123;</div><div class="line">    var obj = finalObj || &#123;&#125;;</div><div class="line">    for (var i in initalObj) &#123;</div><div class="line">        var prop = initalObj[i];</div><div class="line"></div><div class="line">        // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况</div><div class="line">        if(prop === obj) &#123;</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (typeof prop === &apos;object&apos;) &#123;</div><div class="line">            obj[i] = (prop.constructor === Array) ? [] : &#123;&#125;;</div><div class="line">            arguments.callee(prop, obj[i]);</div><div class="line">        &#125; else &#123;</div><div class="line">            obj[i] = prop;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="其他库对深浅拷贝的支持"><a href="#其他库对深浅拷贝的支持" class="headerlink" title="其他库对深浅拷贝的支持"></a>其他库对深浅拷贝的支持</h2><h4 id="1-jquery"><a href="#1-jquery" class="headerlink" title="1. jquery"></a>1. jquery</h4><p>在jquery中有$.clone()和$.extend(),看上去属于拷贝的两个函数，但$.clone()并不用于js对象的深复制，而是用于dom对象。那么$.extend()这个函数就牛啦，就是用来实现深浅复制的。使用方式形如<code>$.extend(true,{},...)</code>，其中第一个参数为true则为深复制，例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var x = &#123;</div><div class="line">    a: 1,</div><div class="line">    b: &#123; f: &#123; g: 1 &#125; &#125;,</div><div class="line">    c: [ 1, 2, 3 ]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var y = $.extend(&#123;&#125;, x),          //shallow copy</div><div class="line">    z = $.extend(true, &#123;&#125;, x);    //deep copy</div><div class="line"></div><div class="line">y.b.f === x.b.f       // true</div><div class="line">z.b.f === x.b.f       // false</div></pre></td></tr></table></figure>
<h4 id="2-underscore"><a href="#2-underscore" class="headerlink" title="2. underscore"></a>2. underscore</h4><p>在underscore中有<code>_.clone()</code>这样一个方法，实际上是一种浅复制，所有嵌套的对象和数组都是直接复制引用而并没有进行深复制<br>源码是这么写的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Create a (shallow-cloned) duplicate of an object.</div><div class="line">_.clone = function(obj) &#123;</div><div class="line">  if (!_.isObject(obj)) return obj;</div><div class="line">  return _.isArray(obj) ? obj.slice() : _.extend(&#123;&#125;, obj);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="3-lodash"><a href="#3-lodash" class="headerlink" title="3. lodash"></a>3. lodash</h4><p>实际上在有了lodash以后我就不再使用underscore了，在lodash中有两个复制的方法：<code>_.clone()</code>和<code>_.cloneDeep()</code>，其中<code>_.clone(obj,true)</code>等价于<code>_.cloneDeep(obj)</code></p>
<h4 id="4-es6"><a href="#4-es6" class="headerlink" title="4. es6"></a>4. es6</h4><p>在es6中有个函数是object.assign(),但是很抱歉，实现的是浅复制，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object.assign(&#123;a: &#123;b: 0&#125;&#125;, &#123;a: &#123;b: 1, c: 2&#125;&#125;, &#123;a: &#123;c: 3&#125;&#125;);</div><div class="line">//&#123;a: &#123;c: 3&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js之arguments]]></title>
      <url>/2017/07/27/2017-07-25-js%E4%B9%8Barguments/</url>
      <content type="html"><![CDATA[<blockquote>
<p>最近突然想到以前看到一篇文章讲过arguments的一些属性，决定在重温一遍</p>
</blockquote>
<h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>在MDN的解释是一个类似数组的对象, 对应于传递给函数的参数，在控制台输出可以看出其实就是一个形如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    0: &apos;a&apos;,</div><div class="line">    1: &apos;b&apos;,</div><div class="line">    length: 2</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>的对象，不过除此之外它还有callee和caller两个属性，在下节描述。<br>关于arguments这个对象，常见的操作就是将其转化为数组，这里有两种方法都能将其转化为数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//第一种，使用Array原型方法slice</div><div class="line">Array.prototype.slice.call(arguments)</div><div class="line">   //第二种 ES6新出现的方法</div><div class="line">   Array.from(arguments)</div></pre></td></tr></table></figure></p>
<h2 id="关于callee-和-caller"><a href="#关于callee-和-caller" class="headerlink" title="关于callee 和 caller"></a>关于callee 和 caller</h2><p>其实这两个属性我几乎没用到过，但保不齐哪天需要排上用场呢</p>
<h3 id="1-callee"><a href="#1-callee" class="headerlink" title="1. callee"></a>1. callee</h3><p>当函数被调用时，它的arguments.callee对象指向自身，也就是对自己的一个引用，这个属性我认为基本用不上</p>
<h3 id="2-caller"><a href="#2-caller" class="headerlink" title="2. caller"></a>2. caller</h3><p>在一个函数调用另一个函数时，被调用函数会自动生成一个caller属性，指向调用它的函数对象<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function testCaller() &#123;  </div><div class="line">    var caller = testCaller.caller;  </div><div class="line">    console.log(caller); </div><div class="line">    /** 输出内容</div><div class="line">        function aCaller() &#123;  </div><div class="line">            testCaller();  </div><div class="line">        &#125;</div><div class="line">    **/</div><div class="line">&#125;  </div><div class="line">  </div><div class="line">function aCaller() &#123;  </div><div class="line">    testCaller();  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">aCaller();</div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2017-06-28随笔]]></title>
      <url>/2017/06/28/2017-06-28%E9%9A%8F%E7%AC%94/</url>
      <content type="html"><![CDATA[<blockquote>
<p>最近一段时间没怎么更新博客了，说实话挺多事情的，包括工作上的，生活中的，等等…</p>
</blockquote>
<h2 id="js中常用的相关高度和宽度"><a href="#js中常用的相关高度和宽度" class="headerlink" title="js中常用的相关高度和宽度"></a>js中常用的相关高度和宽度</h2><ul>
<li>网页可见区域宽： document.body.clientWidth </li>
<li>网页可见区域高： document.body.clientHeight </li>
<li>网页可见区域宽： document.body.offsetWidth (包括边线的宽) </li>
<li>网页可见区域高： document.body.offsetHeight (包括边线的高) </li>
<li>网页正文全文宽： document.body.scrollWidth </li>
<li>网页正文全文高： document.body.scrollHeight </li>
<li>网页被卷去的高： document.body.scrollTop </li>
<li>网页被卷去的左： document.body.scrollLeft </li>
<li>网页正文部分上： window.screenTop </li>
<li>网页正文部分左： window.screenLeft </li>
<li>屏幕分辨率的高： window.screen.height </li>
<li>屏幕分辨率的宽： window.screen.width </li>
<li>屏幕可用工作区高度： window.screen.availHeight </li>
<li>屏幕可用工作区宽度： window.screen.availWidth </li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 随笔写写 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[趣味js]]></title>
      <url>/2017/06/01/%E8%B6%A3%E5%91%B3JS/</url>
      <content type="html"><![CDATA[<p>最近碰到一些有意思的js问题，随手记录下来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">console.log(a); //=&gt; [Function: a]</div><div class="line">var a = 1;</div><div class="line">function a() &#123;</div><div class="line">    return 2</div><div class="line">&#125;</div><div class="line">console.log(a);  //=&gt; 1</div></pre></td></tr></table></figure></p>
<p>上网查询相关资料后发现，<code>函数声明的优先级高于变量声明的优先级，但不会覆盖变量赋值</code>。</p>
<p>我再把<code>function a</code>换成函数表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">console.log(a); //=&gt; undefined</div><div class="line">var a = 1;</div><div class="line">console.log(a)	//=&gt; 1</div><div class="line">var a = function() &#123;</div><div class="line">    return 2</div><div class="line">&#125;</div><div class="line">console.log(a);  //=&gt; [Function: a]</div></pre></td></tr></table></figure></p>
<p>可以看出，函数声明会提前，也就是说函数声明是在浏览器准备执行代码的时候执行的；而函数表达式是在只是单纯的赋值语句，会覆盖原有值；</p>
]]></content>
      
        
        <tags>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES2016初体验]]></title>
      <url>/2017/05/18/es7%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h2 id="ES2016的最新特性"><a href="#ES2016的最新特性" class="headerlink" title="ES2016的最新特性"></a>ES2016的最新特性</h2><p><code>ES2016</code>(简称es7)在2016年6月已经正式发布了。相比<code>ES2015(ES6)</code>,<code>ES2016</code>的新特性并不多，所以可能大家也并没有对其作太多的关注，但是并不表示这些新特性就不重要。本文将会对ES2016的部分新特性作一个介绍。</p>
<h3 id="Array-includes"><a href="#Array-includes" class="headerlink" title="Array.includes"></a>Array.includes</h3><p>数组的新方法<code>includes(element, [fromIndex])</code>用以检查数组中是否存在<code>element</code>元素，然后返回一个布尔值(true/false)。可选的<code>fromIndex</code>允许指定开始搜索的位置。</p>
<p>基础用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const elements = [&apos;pig&apos;, &apos;dog&apos;, &apos;cat&apos;]</div><div class="line">elements.includes(&apos;pig&apos;)	// =&gt; true</div><div class="line">elements.includes(&apos;horse&apos;)	// =&gt; false</div></pre></td></tr></table></figure></p>
<p><code>pig</code>存在于<code>elements</code>数组中，所以<code>includes</code>方法返回<code>true</code>。而对于<code>horse</code>，由于其在<code>elements</code>数组中不存在，故返回<code>false</code>。</p>
<p>需要注意的是，<code>includes()</code>方法必须匹配到严格相等的类型才会返回<code>true</code>。也就是说，<code>includes()</code>方法在比较的时候相当于<code>===</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const items = [1, &apos;2&apos;, 3]</div><div class="line">items.includes(2) 	// =&gt; false</div><div class="line">items.includes(3) 	// =&gt; true</div></pre></td></tr></table></figure></p>
<p>当匹配对象的时候，<code>includes()</code>方法比较的是对象的引用是否相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">  constructor(name) &#123;</div><div class="line">    this.name = name</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">const personA = new Person(&apos;Linda&apos;)</div><div class="line">const personB = new Person(&apos;Calvin&apos;)</div><div class="line">const persons = [personA, new Person(&apos;Calvin&apos;)]</div><div class="line">persons.includes(personA) 	// =&gt; true</div><div class="line">persons.includes(personB) 	// =&gt; false</div></pre></td></tr></table></figure></p>
<p>在使用可选参数<code>fromIndex</code>时的使用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const companies = [&apos;baidu&apos;, &apos;alibaba&apos;, &apos;tencent&apos;]</div><div class="line">companies.includes(&apos;baidu&apos;, 1) 	// =&gt; false</div><div class="line">companies.includes(&apos;tencent&apos;, 1) 	// =&gt; true</div><div class="line">companies.includes(&apos;alibaba&apos;, 5) 	// =&gt; false</div></pre></td></tr></table></figure></p>
<p><code>includes()</code>有一个特别的地方需要注意。我们知道，<code>NaN === NaN</code>返回的是<code>false</code>。但是，<code>includes()</code>方法却能查找数组中的<code>NaN</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const array = [1, 2, NaN]</div><div class="line">array.includes(NaN) 	// =&gt; true</div></pre></td></tr></table></figure></p>
<h3 id="乘方运算符"><a href="#乘方运算符" class="headerlink" title="乘方运算符"></a>乘方运算符</h3><p>ES2016中的乘方运算符<code>**</code>允许你作乘方运算，这在一些场景中会减少一些比较恶心的<code>for</code>循环运算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2 ** 3 	// =&gt; 8</div><div class="line">6 ** 2 	// =&gt; 36</div><div class="line">0.8 ** 1 	// =&gt; 0.8</div></pre></td></tr></table></figure></p>
<p>我们知道，在基本运算（加减乘除）中，有简写的<code>+=</code>、<code>-=</code>、<code>*=</code>和<code>/=</code>操作。同样，对于乘方运算符，也有这样的简写方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let number = 3</div><div class="line">number **= 3</div><div class="line">number;	// =&gt; 27</div></pre></td></tr></table></figure>
<p>对于乘方运算的一些特殊情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">10 ** 0 	// =&gt; 1</div><div class="line">NaN ** 0 	// =&gt; 1</div><div class="line">Infinity ** 0 	// =&gt; 1</div><div class="line">10 ** NaN 	// =&gt; NaN</div><div class="line">NaN ** NaN 	// =&gt; NaN</div></pre></td></tr></table></figure></p>
<h3 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h3><p>当然，还有众所周知的async,await,对于async,await的讲解，我这里推荐阅读<a href="https://cnodejs.org/topic/5640b80d3a6aa72c5e0030b6" target="_blank" rel="external">体验异步的终极解决方案-ES7的Async/Await</a></p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>目前最新版的<code>Chrome</code>浏览器已经完全支持这些新特性，所以你完全可以在不依赖<code>babel</code>的情况下使用这些新特性。</p>
<p>当然还有很多新特性，ES5,ES6出来以后我已经完全抛弃了undersource这类库，后续更新其他新玩法。嗯，暂且先这样吧。</p>
]]></content>
      
        
        <tags>
            
            <tag> es2016 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vue入坑指南（一）]]></title>
      <url>/2017/04/22/vue%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>初入前端三大框架之一：vue，以此系列记录学习路上踩过的坑</p>
</blockquote>
<h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><p>刚接触vue组件化编程，说实话有点不太适用，深受长久使用jquery操作dom之害，一开始使用vue就踩坑了。</p>
<p>vue的一大重大思想就是推荐我们使用小型、自包含的可复用的组件来构建大型应用，即组件是应用中独立的单元模块。那么问题来了，对于组件中导入其他组件的话，该怎么进行数据绑定和交互。在一开始我看到一些<code>$emit</code>，<code>props</code>，<code>ref</code>这类关键词是有点懵逼的，因为官方文档实在太长了，我是直接安装vue-cli生成项目直接开干的，导致刚开始有点懵，后来一通查询api算是搞明白了。</p>
<ul>
<li><p><strong>父组件向自组件通信</strong></p>
<p>  在子组件要显式申明props</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 子组件声明</div><div class="line">exprot default &#123;</div><div class="line">    props:&#123;</div><div class="line">        myMsg:&#123;</div><div class="line">            type: String,</div><div class="line">            default: &apos;&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  在父组件调用处,由于html特性是不区分大小写，所以当使用的不是字符串模版，驼峰式命名的prop需要转换为相应的短横线隔开式</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 省略组件的导入和注册</div><div class="line">&lt;child my-msg=&quot;hello&quot;&gt;&lt;/child&gt;</div><div class="line"></div><div class="line">// 也可以给指定值为父组件属性</div><div class="line">&lt;child :my-msg=&quot;message&quot;&gt;&lt;/child&gt;</div><div class="line">export default &#123;</div><div class="line">    data ()&#123;</div><div class="line">        return &#123;</div><div class="line">            message:&apos;&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  <code>.sync修饰符</code></p>
<p>  在vue1.x时用来实现父子组件props双向绑定，但发现了一些问题-&gt;官方是这么说的，所以在vue2.0时移除了这个修饰符，但在vue2.3时又引入了，不过代表的是另一层含义-&gt;只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 侦听器。<br>  例如：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt;</div></pre></td></tr></table></figure>
<p>  会被扩展为：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;comp :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/comp&gt;</div></pre></td></tr></table></figure>
<p>  当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.$emit(&apos;update:foo&apos;, newValue)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>子组件向父组件通信</strong></p>
<p>  在子组件中：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;template&gt;</div><div class="line">    &lt;div @click=doSomething(&apos;123&apos;) &gt;&lt;/div&gt;</div><div class="line">&lt;/template&gt;</div><div class="line">...</div><div class="line">methods: &#123;</div><div class="line">    doSomething: function(id)&#123;</div><div class="line">        this.$emit(&apos;do&apos;,id);</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>  在父组件中：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;child @do=&quot;onDo&quot;&gt;&lt;/child&gt;</div><div class="line"></div><div class="line">...</div><div class="line">methods: &#123;</div><div class="line">    onDo: function(id)&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> vue </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Meteor初体验]]></title>
      <url>/2017/04/10/meteor%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h2 id="Meteor文件结构"><a href="#Meteor文件结构" class="headerlink" title="Meteor文件结构"></a>Meteor文件结构</h2><p>通常包含<code>/client</code>、<code>/server</code>、’/public’、’/lib’四个文件夹，当然还有默认的<code>/.meteor</code>文件夹-是Meteor存储内部代码的地方，文件结构如下：</p>
<blockquote>
<ul>
<li>在<code>/client</code>文件夹下的代码只会在客户端运行；</li>
<li>在<code>/server</code>文件夹下的代码只会在服务器运行；</li>
<li>其他代码则会同时运行在服务端和客户端；</li>
<li>静态文件（如：字体，图片等）存放在<code>public</code>文件夹下；</li>
</ul>
</blockquote>
<p><strong>Meteor加载文件顺序：</strong></p>
<ul>
<li>在<code>/lib</code>下的文件优先加载；</li>
<li>所有以<code>main.*</code>命名的文件将会在其他文件载入后载入；</li>
<li>其他文件以文件名字母顺序载入；</li>
</ul>
<h2 id="模板系统"><a href="#模板系统" class="headerlink" title="模板系统"></a>模板系统</h2><p>meteor开发的单页应用，只有一个主页面，任何看似页面的切换，实际页面并没有跳转，而是在此页面进行模板替换。故模板是应用中的基础组成部分。</p>
<h3 id="1-模板开始"><a href="#1-模板开始" class="headerlink" title="1.模板开始"></a>1.模板开始</h3><p>模板的核心组成是一对HTML、JS文件，约定俗成的命名方式是<code>template_name.html</code>、<code>template_name.js</code>，Meteor的模板引擎是Blaze-简洁、好用的响应式UI库。<br>Blaze的核心部分包括两部分：</p>
<blockquote>
<ul>
<li>runtime API–响应式API</li>
<li>compiler–负责编译模板</li>
</ul>
</blockquote>
<h3 id="2-模板用法"><a href="#2-模板用法" class="headerlink" title="2.模板用法"></a>2.模板用法</h3><p><strong>关于</strong></p>
<h2 id="Meteor集合"><a href="#Meteor集合" class="headerlink" title="Meteor集合"></a>Meteor集合</h2><p>在Meteor中，关键词<code>var</code>限制对象的作用域在文件范围内，不用<code>var</code>声明则可以作用于整个应用范围内。</p>
<h2 id="mogodb"><a href="#mogodb" class="headerlink" title="mogodb"></a>mogodb</h2><h3 id="1-模糊搜索"><a href="#1-模糊搜索" class="headerlink" title="1.模糊搜索"></a>1.模糊搜索</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">collection.find(&#123;name: new RegExp(&quot;^.*&quot;+name+&quot;.*$&quot;)&#125;)</div></pre></td></tr></table></figure>
<p>使用正则查询实现模糊搜索mongo db</p>
]]></content>
      
        
        <tags>
            
            <tag> meteor </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[vuex入坑]]></title>
      <url>/2017/03/18/webpack%E8%84%B1%E5%9D%91%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<p>webpack是目前一个很热门的前端打包工具，官网说得很清楚，webpack的出现就是要把requirejs干掉。同时它还提供了十分便利的本地开发的环境。网上并不容易找到一个讲解得比较详细完整的教程，本文结合实践经验，总结一套可用的开发和上线的配置和流程。</p>
<p>首先， <a href="http://requirejs.org/" target="_blank" rel="external">Require JS</a> 有什么问题</p>
<h2 id="RequireJs存在的问题"><a href="#RequireJs存在的问题" class="headerlink" title="RequireJs存在的问题"></a><strong>RequireJs存在的问题</strong></h2><p>博主先是使用了RequireJs，后来又转了webpack，综合比较，requirejs确实存在一些缺点：</p>
<h3 id="1-写法比较笨拙"><a href="#1-写法比较笨拙" class="headerlink" title="1.写法比较笨拙"></a><strong>1.写法比较笨拙</strong></h3><p>需要把所有的依赖模块写在require函数里面，当模块很多的时候，看起来逼格就不高了，感受如下：</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20160907/20160907140325_981.png" alt=""></p>
<p>而webpack既兼容requirejs的写法，也兼容commonjs的写法，也就是说，使用webpack你既可以继续像上面那样写，也可以像node那样写，感受如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var modules = &#123;</div><div class="line">signHandler: require(&quot;module/sign-log&quot;),</div><div class="line">chatHandler: require(&quot;module/chat-win&quot;),</div><div class="line">mapHandler: require(&quot;lib/map&quot;),</div><div class="line">util: require(&quot;lib/util&quot;)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以在需要的时候再去require，而不是搞个大括号把全部的模块一下子写到一起。（模块的导出用module.exports = ….）</p>
<p>当然这两种写法不仅是感光上的区别，逻辑上也有区别。用中括号加载的模块通常webpack是动态去加载，而没有中括号是和主文件打包在一起的。</p>
<h3 id="2-没有通用模块的概念"><a href="#2-没有通用模块的概念" class="headerlink" title="2. 没有通用模块的概念"></a><strong>2. 没有通用模块的概念</strong></h3><p>例如有一个弹框模块，用在登陆注册，并且所有页面都有登陆注册，所以这是一个所有页面的通用模块。如果页面的其它模块都没调到通用模块里面的东西的话 ，用RequireJs没什么问题。但是实际情况上不是这样的，例如util模块既会被登陆注册的模块调用，也会被很多其它模块调用。这个时候合并压缩就有问题了：合并后的通用模块如common-app.js会带上util的代码、另外一个页面的例如detail.js也会带上util的代码，以后一改util.js里面的东西，就会一并改动其它所有用到util的页面js，就得重新打所有js的版本号。这样无论对布署上线，还是对于用户的缓存来说都是不利的。</p>
<p>webpack可以把几个文件的通用模块抽出来单独作为一个模块common-chunk.js，引用的时候每个页面先引一个common-chunk.js，再引一个该页面自己的js文件如detail.js，原detail.js里面和其它js文件共用的模块已经被提取到common-chunk.js里面。</p>
<h3 id="3-没办法直接动态合并压缩一个需要异步加载的模块"><a href="#3-没办法直接动态合并压缩一个需要异步加载的模块" class="headerlink" title="3. 没办法直接动态合并压缩一个需要异步加载的模块"></a><strong>3. 没办法直接动态合并压缩一个需要异步加载的模块</strong></h3><p>这个问题是这样的，假设我的聊天模块文件有500Kb这么大，并不希望一刷页面就加载，而是用户点了聊天再去加载。这个聊天模块有一个入口文件和其它几 个模块文件，我合并压缩了入口文件，需要有一个输出文件，而入口文件define的模块名和压缩优化后的输出文件的路径肯定是要不一样的，但是压缩之后他并不会自动去改变输 出文件的模块名。这样就导致你要手动去改一下压缩文件的模块名，不然会require不到。我之前找了一下，没有找到解决方案，所以采取了一个压缩两次的比较笨拙的方法。</p>
<p>而webpack有一个文件束chunkFile的概念，它会自动去把需要异步加载的文件变成一个chunkFile，然后触发加载的时候再去加载chunkFile。</p>
<h3 id="4-需要借助gulp等管理工具进行开发"><a href="#4-需要借助gulp等管理工具进行开发" class="headerlink" title="4. 需要借助gulp等管理工具进行开发"></a><strong>4. 需要借助gulp等管理工具进行开发</strong></h3><p>webpack本身有一些插件和第三方的插件，可以在本地开一个webpack-dev-server，文件一保存的时候就会自动打包编译js/css/less/sass等。</p>
<p>使用RequireJs虽然看起来缺点比较多，但是使用RequireJs也有webpack不具备的优点，那就是RequireJs开发的时候在浏览器里面，每个模块都是单独一个文件，跟本地文件保持一致，而webpack是把主文件和该文件都用到的模块都打包成了一个文件，这样在调试的时候就需要你去搜索找到要调试的位置，而使用requireJs直接根据第几行就可以了。不过，考虑到使用webpack可以搭建一个很方便的本地开发环境，所以这个缺点也不是很明显。</p>
<h2 id="使用webpack"><a href="#使用webpack" class="headerlink" title="使用webpack"></a><strong>使用webpack</strong></h2><p>用一句概括就是：写一个配置文件，然后执行下webpack，就可以把生成的文件输出，可压缩带版本号，同时生成一个source-map文件，这个文件包含了每个模块的js和css的实际(带版本号)路径，根据这个路径就可以把html里面的js/css等换成真实的路径。</p>
<p>webpack是一个打包的工具，它有一个重要的概念，就是把js/css/image/coffee都当成地位相等的资源，你可以在js里面require一个css，也可以require一个image。但是这种模式比较适用于React等框架，都是用js控制。</p>
<p>webpack的其它几个重要概念：</p>
<h3 id="1-loader加载器"><a href="#1-loader加载器" class="headerlink" title="1. loader加载器"></a><strong>1. loader加载器</strong></h3><p>上面说到，各种各样的资源都可以在webpack里面加载，而这些资源都需要相应的加载器，webpack才能识别，然后解析成正常的浏览器认识的资源。</p>
<p>换句话说， 你可以给webpack加载各种各样的资源：css/less/sass/png/babel等，然后在代码里面进行管理。</p>
<p>例如要加一个sass的loader，需要先安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install sass-loader node-sass</div></pre></td></tr></table></figure>
<p>然后在配置文件添加一个loader:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">test: /\.sass$/,</div><div class="line">loaders: [&quot;style&quot;, &quot;css&quot;, &quot;sass&quot;]</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>这样当你require(“hello.sass”)的时候，webpack就能处理这种.sass结尾的文件。这样子有两个好处，一个是webpack能够自动编译sass为css，另一个是require进来的style，webpack会把它解析成一个object，这个object的key就是类名，就可以在js使用样式的类名，这种比较适合类似于react的开发模式。</p>
<h3 id="2-文件束chunk"><a href="#2-文件束chunk" class="headerlink" title="2. 文件束chunk"></a><strong>2. 文件束chunk</strong></h3><p>上面提到的，会把动态加载的文件生成一个个的chunk， 在配置文件的output里面加一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chunkFilename: &quot;bundle-[id].js&quot;</div></pre></td></tr></table></figure>
<p>就会根据id区分不同动态加载的chunk文件，而这些chunk文件名对于我们来说是无关紧要，因为这个是webpack管理的，开发者无需关心叫什么又是怎么加载的。</p>
<h3 id="3-webpack-dev-server"><a href="#3-webpack-dev-server" class="headerlink" title="3. webpack-dev-server"></a><strong>3. webpack-dev-server</strong></h3><p>这是webpack的一个插件，可以在本地开一个静态服务，用来作为本地开发的重要工具。具体步骤就是html里面引用的资 源用一个假的域名，如develop.com：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;//develop.com/site/app-init.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>然后再把develop.com绑到本地回路:</p>
<p>127.0.0.1 fedren.com</p>
<p>这样请求就打到了本地的80端口。同时在本地开一个nginx监听在80端口，nginx收到80端口的请求后，再把请求转发到webpack的服务(默认是8080端口)。这样就能够实现本地开发，下文会具体介绍。</p>
<p>下面一步步介绍怎么配置和使用webpack</p>
<h2 id="webpack的基本配置"><a href="#webpack的基本配置" class="headerlink" title="webpack的基本配置"></a><strong>webpack的基本配置</strong></h2><p>首先，npm init创建一个node的配置文件package.json，然后安装webpack：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install webpack</div><div class="line">sudo npm install webpack -g //安装一个全局的命令</div></pre></td></tr></table></figure>
<p>再创建一个webpack.config.js文件，加入最基本的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">// The standard entry point and output config</div><div class="line">//每个页面的js文件</div><div class="line">entry: &#123;</div><div class="line">home: &quot;js/home&quot;,</div><div class="line">detail: &quot;js/detail&quot;</div><div class="line">&#125;,</div><div class="line">output: &#123;</div><div class="line">path: &quot;assets&quot;, //打包输出目录</div><div class="line">publicPath: &quot;/static/build/&quot;, //webpack-dev-server访问的路径</div><div class="line">filename: &quot;[name].js&quot;, //输出文件名</div><div class="line">chunkFilename: &quot;bundle-[id].js&quot; //输出chunk文件名</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>工程的js都放到js目录下，一个叫home.js，另一个叫detail.js，输出到assets目录，publicPath是为webpack-dev-server所使用</p>
<p>然后在当前目录执行webpack，发现webpack报错了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERROR in Entry module not found: Error: Cannot resolve module &apos;js/home&apos; in /Users/yincheng/code/blog-webpack</div></pre></td></tr></table></figure>
<p>找不到js/home的模块，只要在配置里面加一句resolve：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">resolve: &#123;</div><div class="line">modulesDirectories: [&apos;.&apos;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>告诉webpack所有模块的启始目录由当前目录开始，再执行下webpack就可以正常输出了：</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20160907/20160907140326_686.png" alt=""></p>
<p>到目前为此，当前工程的目录结构就是这样的了：</p>
<p><img src="http://static.open-open.com/lib/uploadImg/20160907/20160907140326_976.png" alt=""></p>
<p>接下来，创建html：home.html，里面引入js文件，”static/build”即为上面定义的publicPath：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">&lt;p&gt;home.html&lt;/p&gt;</div><div class="line">&lt;script src=&quot;//develop.com/static/build/home.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<p>注意我们用了一个develop.com的域名，把这个域名绑到本地回路：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">127.0.0.1 develop.com</div></pre></td></tr></table></figure>
<p>然后配置nginx，打开nginx.conf，加多一个server:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">listen 80;</div><div class="line">server_name payment-admin.com;</div><div class="line">charset utf-8;</div><div class="line">#工程路径</div><div class="line">root /Users/yincheng/code/demo;</div><div class="line">autoindex on;</div><div class="line">autoindex_exact_size on;</div><div class="line"></div><div class="line">location ~* /.+\.[a-z]+$ &#123;</div><div class="line">proxy_set_header x-request-filename $request_filename;</div><div class="line"># webpack的服务</div><div class="line">proxy_pass http://127.0.0.1:8080;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>启动nginx或者重启下nginx</p>
<p>然后再装一个webpack-dev-server：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install webpack-dev-server --save-dev</div><div class="line">sudo npm install webpack-dev-server -g</div></pre></td></tr></table></figure>
<p>然后启动webpack-dev-server，执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack-dev-sever --port=8080 //不加port参数，默认就为8080端口</div></pre></td></tr></table></figure>
<p>然后就可以访问：<a href="http://develop.com/html/home.html" target="_blank" rel="external">http://develop.com/html/home.html</a></p>
<p><img src="http://static.open-open.com/lib/uploadImg/20160907/20160907140326_346.png" alt=""></p>
<p>这个时候，只要一改变home.js的内容，webpack-dev-server就会自动打包新的文件 ，一刷新页面，就是最新的修改了。这样就实现了最基本的本地开发，不管你用的jsp/php，都不需要把js/css往服务器上传。 注意webpack-dev-server是在内存生成的文件，你在本地是找不到static/build目录的，只有执行了webpack打包才会输出文件到assets目录。一个为上面配置里的publicPath，另一个为path。</p>
<p>引入样式文件——首先创建css/home.css：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">body&#123;</div><div class="line">color: #f00;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在js里面引入这个css文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">require(&quot;css/home.css&quot;);</div></pre></td></tr></table></figure>
<p>一保存之后，会发现webpack-dev-server报错了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ERROR in ./css/home.css</div><div class="line">Module parse failed: /Users/yincheng/code/blog-webpack/css/home.css Unexpected token (1:4)</div><div class="line">You may need an appropriate loader to handle this file type.</div></pre></td></tr></table></figure>
<p>根据提示，我们需要加装一个css loader，让webpack能够处理css文件，更改webpack.config.js，加入一个loader：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">entry: ...,</div><div class="line">output: ...,</div><div class="line">resolve: ...,</div><div class="line">module: &#123;</div><div class="line">loaders: [</div><div class="line">&#123;</div><div class="line">test: /\.css$/,</div><div class="line">loader: &quot;style-loader!css-loader&quot;</div><div class="line">&#125;,</div><div class="line">]</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当然要先安装一下：npm install style-loader css-loader –save-dev，然后再重启下webpack-dev-server，就可以加载样式了，我们发现webpack是把样式动态插到了head标签的style里面，但是一般并不希望直接写到head里面，而是独立的一个css文件，这个时候借助一个分离css的插件就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install extract-text-webpack-plugin --save-dev</div></pre></td></tr></table></figure>
<p>同时把配置文件的loader改一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);</div><div class="line">module.exports = &#123;</div><div class="line">module: &#123;</div><div class="line">loaders: [</div><div class="line">// Extract css files</div><div class="line">&#123;</div><div class="line">test: /\.css$/,</div><div class="line">loader: ExtractTextPlugin.extract(&quot;style-loader&quot;, &quot;css-loader&quot;)</div><div class="line">&#125;,</div><div class="line">]</div><div class="line">&#125;,</div><div class="line"></div><div class="line">plugins: [</div><div class="line">new ExtractTextPlugin(&quot;[name].css&quot;)</div><div class="line">]</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>就会生成和js相同路径和名字的css文件，在home.html里面引入css文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;//develop.com/static/build/home.css&quot;&gt;&lt;/link&gt;</div></pre></td></tr></table></figure>
<p>你也可以加载各种各样的loader，如加载一个sass/less loader，require一个sass/less文件后就可以写sass/less了，webpack会把它编译成和上面一样普通的css文件，读者可以自己试试，还可以再装一个png/jpg的loader，指定一个小于多少个k的图片的参数，webpack就会把小于指定尺寸的图片转成base64的格式。各种loader的安装查一查就有了。</p>
<p>到这里一个最基本的本地开发环境就已经搭起来了。接下来讨论自动刷新</p>
<h2 id="自动刷新"><a href="#自动刷新" class="headerlink" title="自动刷新"></a><strong>自动刷新</strong></h2><p>上面一保存js/css的时候，webpack server就会自动打包，刷新页面的时候就是最新的修改。这个刷新只要使用webpack的hot模式就可以自动实现，即一保存就自动打包刷新。将上面运行webpack-dev-server的命令再加多两个参数，按照官方文档的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack-dev-server --port=8383 --hot --inline</div></pre></td></tr></table></figure>
<p>如果没有意外，在你的电脑上将会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ERROR in multi home</div><div class="line">Module not found: Error: Cannot resolve module &apos;webpack/hot/dev-server&apos; in /Users/yincheng/code/blog-webpack</div><div class="line">@ multi home</div></pre></td></tr></table></figure>
<p>这个问题困惑了笔者好久，因为在node_modules里面是有这个”webpack/hot/dev-server”的，其实只要认真看下上面的提示，就会发现它并不是说在node_modules里面，而是在当前工程目录里，所以把node_modules里的webpack文件夹拷一份到外面就可以正常运行了。（如果你又配了个context的参数的话，那就根据提示拷到context指定的目录）</p>
<p>使用hot模式，只要一保存js/css就可以自动刷新了，这个功能确实很方便。如果不写参数，也可以把它写在配置文件里面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var hotModuleReplacementPlugin = require(&quot;webpack/lib/HotModuleReplacementPlugin&quot;);</div><div class="line">module.exports = &#123;</div><div class="line">plugins: [</div><div class="line">new ExtractTextPlugin(&quot;[name].css&quot;),</div><div class="line">new hotModuleReplacementPlugin()</div><div class="line">],</div><div class="line">devServer: &#123;</div><div class="line">historyApiFallback: true,</div><div class="line">hot: true,</div><div class="line">inline: true,</div><div class="line">progress: true</div><div class="line">&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后运行server就不用带上后面那两个参数了。</p>
<h2 id="Common-chunk"><a href="#Common-chunk" class="headerlink" title="Common chunk"></a><strong>Common chunk</strong></h2><p>如上文提到，webpack可以将几个js的公共模块提取成一个chunk，需要借助一个commonChunkPlugin，在上面的plugins再添加一个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var CommonsChunkPlugin = require(&quot;webpack/lib/optimize/CommonsChunkPlugin&quot;);</div><div class="line">plugins: [</div><div class="line">new CommonsChunkPlugin(&#123;</div><div class="line">//minChunks: 3,</div><div class="line">name: &quot;common-app.chunk&quot;,</div><div class="line">chunks: [&quot;home&quot;, &quot;detail&quot;, &quot;list&quot;]</div><div class="line">&#125;)</div><div class="line">]</div></pre></td></tr></table></figure>
<p>这样就可以把home、detail、list三个js和css用到的公共模块提取到common-app.chunk.js和common-app.chunk.css这两个文件了。注意页面要先引入这两个文件，然后再引入具体页面的js，webpack在common chunk里面定义了它的require函数。如上面的home.html：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;script src=&quot;//develop.com/static/build/common-app.chunk.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;//develop.com/static/build/home.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>可以指定一个minChunk的参数，指定模块至少被require几次才能提取出来，默认是3</p>
<p>还可以定义两个commonChunk，例如在详情页、列表页和首页都有搜索的模块，而其它页面没有搜索的模块，也就是说除了所有页面都有的公共模块如登陆注册外，还有一个搜索的公共模块有三个页面要用到。如果都用一个common chunk，会把搜索的也放进来，但其它很多页面并不需要用到。这个时候需要加多一个common chunk：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">plugins: [</div><div class="line">new CommonsChunkPlugin(&#123;</div><div class="line">name: &quot;search-app.chunk&quot;,</div><div class="line">chunks: [&quot;search-app-init&quot;, &quot;home&quot;, &quot;detail&quot;, &quot;list&quot;]</div><div class="line">&#125;),</div><div class="line">new CommonsChunkPlugin(&#123;</div><div class="line">name: &quot;common-app.chunk&quot;,</div><div class="line">chunks: [&quot;home&quot;, &quot;detail&quot;, &quot;search-map&quot;, &quot;search-app.chunk&quot;, &quot;sell&quot;, &quot;about&quot;, &quot;blog&quot;]</div><div class="line">&#125;)</div><div class="line">]</div></pre></td></tr></table></figure>
<p>注意要把search-app.chunk也写到下面那个所有页面的chunk里面，否则webpack会定义两个一样的require函数，页面的模块也会跟着混乱，一刷页面就报错。页面引用js的顺序就变成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;script src=&quot;//develop.com/static/build/common-app.chunk.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;//develop.com/static/build/search-app.chunk.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;//develop.com/static/build/home.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<h2 id="压缩和版本号"><a href="#压缩和版本号" class="headerlink" title="压缩和版本号"></a><strong>压缩和版本号</strong></h2><p>压缩只需要要在plugins里面再添加一个用来压缩的插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var webpack = require(&quot;webpack&quot;);</div><div class="line">plugins: [</div><div class="line">new webpack.optimize.UglifyJsPlugin()</div><div class="line">]</div></pre></td></tr></table></figure>
<p>这样执行webpack输出的js/css就是压缩的</p>
<p>版本号就是在输出带上hash的替换符，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">output: &#123;</div><div class="line">path: &quot;assets&quot;,</div><div class="line">publicPath: &quot;/static/build/&quot;,</div><div class="line">filename: &quot;[name]-[chunkhash].js&quot;,</div><div class="line">chunkFilename: &quot;bundle-[chunkhash].js&quot;</div><div class="line">&#125;,</div><div class="line"></div><div class="line">plugins: [</div><div class="line">new ExtractTextPlugin(&quot;[name]-[contenthash].css&quot;)</div><div class="line">],</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中js用的是webpack的chunkhash，而css用的是contenthash，contenthash是根据内容生成的hash。如果不用contenthash，那么一改js，css的版本号也会跟着改变，这个就有问题了。webpack还有另外一个自带的叫做”[hash]”，这个hash是所有文件都用的同一个哈希，也就是说某个文件改了，所有文件的版本号都会跟着改，所以一般不用这个。</p>
<p>运行webpack，如果报了下面这个错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ERROR in chunk detail [entry]</div><div class="line">[name]-[chunkhash].js</div><div class="line">Cannot use [chunkhash] for chunk in &apos;[name]-[chunkhash].js&apos; (use [hash] instead)</div></pre></td></tr></table></figure>
<p>那你就把plugins里面的热替换插件注释掉就好了，上线的config不需要热替换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">plugins: [</div><div class="line">//new hotModuleReplacementPlugin(),</div><div class="line">],</div></pre></td></tr></table></figure>
<p>成功执行后，就会在设定的output目录下面输出加上版本号的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── detail-d19e4614a1c4f3c1581b.js</div><div class="line">├── home-11198f8526424e8c58ce10a2799793e3.css</div><div class="line">└── home-5ec13a52eea2a6faf96a.js</div></pre></td></tr></table></figure>
<p>有了版本号之后，下一步是要把html里面的js/css换成带版本号的路径</p>
<h2 id="替换Html里js-css路径"><a href="#替换Html里js-css路径" class="headerlink" title="替换Html里js/css路径"></a><strong>替换Html里js/css路径</strong></h2><p>之前在html里的路径是test.com，现在要把它换成cdn且带版本号的路径，也就是说，目标是要把下面的引入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;//develop.com/static/build/home.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>替换成下面的引入，并把新生成的html输出到built目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;script src=&quot;//cdn.mycdn.com/test/home-5ec13a52eea2a6faf96a.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>目测没有现成符合格式的插件可以用，可以自已用node写一个，不费事。</p>
<p>首先要知道所有文件的对应的版本号，可以用 AssetsPlugin，生成source-map：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var AssetsPlugin = require(&apos;assets-webpack-plugin&apos;);</div><div class="line">output: &#123;</div><div class="line">publicPath: &quot;//cdn.mycdn.com/static/build/&quot;</div><div class="line">&#125;,</div><div class="line">plugins: [</div><div class="line">new AssetsPlugin(&#123;filename: &apos;./source-map.json&apos;, prettyPrint: true&#125;),</div><div class="line">]</div></pre></td></tr></table></figure>
<p>执行webpack之后，就会生成source-map.json，打开这个文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&quot;detail&quot;: &#123;</div><div class="line">&quot;js&quot;: &quot;//cdn.mycdn.com/static/build/detail-c8a2c82ebe2e48e06564.js&quot;</div><div class="line">&#125;,</div><div class="line">&quot;home&quot;: &#123;</div><div class="line">&quot;js&quot;: &quot;//cdn.mycdn.com/static/build/home-380af86bfeb6fcb477a4.js&quot;,</div><div class="line">&quot;css&quot;: &quot;//cdn.mycdn.com/static/build/home-11198f8526424e8c58ce10a2799793e3.css&quot;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据develop.com开头的以及最后面的home.js/home.css，就可以在上面找到对应的路径名。笔者写了个脚本，可以实现这个功能，详见： <a href="https://github.com/liyincheng/version-control-replace-html" target="_blank" rel="external">version-control-replace-html</a></p>
<p>到这里，整个流程就基本完成了。还有一些优化的步骤</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a><strong>优化</strong></h2><h3 id="1-优化模块id"><a href="#1-优化模块id" class="headerlink" title="1. 优化模块id"></a><strong>1. 优化模块id</strong></h3><p>webpack对于每个模块都是用id标志，而不是用模块的名字，只是为了节省空间。还可以再节省，就是用它自带的 <a href="https://webpack.github.io/docs/optimization.html" target="_blank" rel="external">occurrence-order</a> 插件将最常用的模块靠前，这样可以再节省一点点空间，因为id是从0开始排的，从一位数到n位数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new webpack.optimize.OccurenceOrderPlugin()</div></pre></td></tr></table></figure>
<h3 id="2-移出版本号"><a href="#2-移出版本号" class="headerlink" title="2. 移出版本号"></a><strong>2. 移出版本号</strong></h3><p>在上面用了common-chunk的插件，抽离公共模块，在这个common-chunk.js里，webpack会定义每个模块加载的src，以便于加载那些需要动态加载的chunk，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">script.src = __webpack_require__.p + &quot;&quot; + chunkId + &quot;-&quot; +</div><div class="line">&#123;&quot;0&quot;:&quot;0cb48ff1ab1d1156015d&quot;,&quot;5&quot;:&quot;e9e7f761f306c648ccef&quot;,&quot;6&quot;:&quot;cbbdf8e3ad1aba34ced0&quot;&#125;[chunkId] + &quot;.js&quot;;</div></pre></td></tr></table></figure>
<p>从上面可以看出它会把版本号也写在里面，这样就导致一个问题，每改一个js文件，它的版本号就会变化，就会导致common chunk里面的内容发生变化，所以它的版本号也得跟着变，也就是说改了一个文件，影响了两个文件。所以需要把它抽出来，有个插件已经做了这样的事情，叫做 <a href="https://github.com/diurnalist/chunk-manifest-webpack-plugin" target="_blank" rel="external">ChunkManifestPlugin</a> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var ChunkManifestPlugin = require(&apos;chunk-manifest-webpack-plugin&apos;);</div><div class="line">plugins: [</div><div class="line">new ChunkManifestPlugin(&#123;</div><div class="line">filename: &quot;chunk-manifest.json&quot;,</div><div class="line">manifestVariable: &quot;webpackManifest&quot;</div><div class="line">&#125;)</div><div class="line">]</div></pre></td></tr></table></figure>
<p>传两个参数，一个是输出文件名，另一个是变量名，用于上面的script.src，执行webpack后，它会把上面script.src的那一坨东西放到chunk-manifest.json，然后在页面写一个内联的script，定义一个全局变量window.webpackManifest，值为manifest.json里面的内容。笔者已在上面的替换版本号的脚本做处理，只需在页面合适的地方写上一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;!--%webpack manifest%--&gt;</div></pre></td></tr></table></figure>
<p>就会把这行替换成一个script标签。</p>
<h3 id="3-多个common-chunk的优化"><a href="#3-多个common-chunk的优化" class="headerlink" title="3. 多个common-chunk的优化"></a><strong>3. 多个common-chunk的优化</strong></h3><p>在上面写了两个common chunk，在生成的两个chunk文件里面，你会发现大量的的重复代码，已经失去了公共模块的作用，这个问题可以用一个 <a href="https://github.com/soundcloud/move-to-parent-merging-webpack-plugin" target="_blank" rel="external">MoveToParentMergingPlugin</a> 解决，它会把search-app用到的common-app的模块全部移到了common-app，search-app就不会重复common-app的内容了。</p>
<h2 id="html保存自动刷新"><a href="#html保存自动刷新" class="headerlink" title="html保存自动刷新"></a><strong>html保存自动刷新</strong></h2><p>上面提到，只要一保存css/js，webpack-dev-server就会自动保存和刷新，但是html/jsp没办法（如果你用react开发，可以用react-hot-loader），其实可以手动解决这个问题。打开 node_modules/webpack-dev-server/client/index.js这个文件，可以发现webpack是用的sockjs实现自动刷新的。浏览器使用sockjs创建socket客户端，连接到webpack的服务，保存更改的时候，服务就向浏览器的socket发送消息，接收到这个消息后客户端就调window.location.reload刷新页面。所以可以模仿这个过程，在本地另开一个服务，监听html的修改，然后向浏览器端发送刷新页面的消息。</p>
<p>具体来说，首先在上面的node_modules/webpack-dev-server/client/index.js这个文件最后面再添加一个socket连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/*自定义reload window*/</div><div class="line">var reload = new SockJS(&quot;http://localhost:9999/reload&quot;);</div><div class="line">reload.onopen = function()&#123;</div><div class="line">console.log(&quot;customer reload start.......&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">reload.onclose = function()&#123;</div><div class="line">console.log(&quot;customer reload close.......&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">reload.onmessage = function(_msg)&#123;</div><div class="line">var msg = JSON.parse(_msg.data);</div><div class="line">if(msg.type === &quot;reload&quot;)&#123;</div><div class="line">console.log(&quot;customer reload window now&quot;);</div><div class="line">window.location.reload();</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个9999端口的server就是下面要在本地监听的一个socket服务。在开这个socket服务之前，需要先在本地开一个监听文件修改的服务，然后再向这个socket服务发送消息。监听的服务比较好写，有现成的node包可以用： <a href="https://www.npmjs.com/package/chokidar" target="_blank" rel="external">chokidar</a> ，使用也非常简单。监听到修改之后就可以执行上传服务器的命令，然后（使用进程间的通信）再向socket服务发送一个需要刷新的消息，再传递给浏览器的scoket，如上面的代码，一收到消息就刷新页面。具体代码查看 <a href="https://github.com/liyincheng/webpack-tool/tree/master/file-watch" target="_blank" rel="external">github</a></p>
<p>除了优化，在使用中会遇到的一些问题：</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a><strong>解决问题</strong></h2><h3 id="1-umd的require模式"><a href="#1-umd的require模式" class="headerlink" title="1. umd的require模式"></a><strong>1. umd的require模式</strong></h3><p>有时候会引入外部的库，这些库可能会用umd的require模式，判断是要用requirejs还是commonjs或是写个全局的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/* CommonJS */ if (typeof require === &apos;function&apos; &amp;&amp; typeof module === &apos;object&apos; &amp;&amp; module &amp;&amp; typeof exports ===</div><div class="line">&apos;object&apos; &amp;&amp; exports)</div><div class="line">module[&apos;exports&apos;] = init(require(&quot;ByteBuffer&quot;));</div><div class="line">/* AMD */ else if (typeof define === &apos;function&apos; &amp;&amp; define[&quot;amd&quot;])</div><div class="line">define(&quot;lib/chat/ProtoBuf&quot;, [&quot;./ByteBuffer&quot;], init);</div><div class="line">/* Global */ else(global[&quot;dcodeIO&quot;] = global[&quot;dcodeIO&quot;] || &#123;&#125;)[&quot;ProtoBuf&quot;] = init(global[&quot;dcodeIO&quot;][&quot;ByteBuffer&quot;]);</div></pre></td></tr></table></figure>
<p>这个的问题就在于，只要页面上有require出现，webpack就会去打包，不管你是写if里面还click事件里面。因为像上面说的，webpack会把异步加载的文件打包成一个boundle文件，同时也会把非异步的打包到一起。像上面那样写，它会重复打包，生成好多个bundle。只要加多一个 <a href="https://www.npmjs.com/package/umd-require-webpack-plugin" target="_blank" rel="external">umdREquirePlugin</a> ，webpack就能正常打包了。</p>
<h3 id="2-如何加载外部资源"><a href="#2-如何加载外部资源" class="headerlink" title="2. 如何加载外部资源"></a><strong>2. 如何加载外部资源</strong></h3><p>webpack是一个打包的工具，它并不是像requireJs那样可以支持直接require一个外部资源。</p>
<p>例如我要require谷歌地图：<a href="https://maps.googleapis.com/maps/api/js，打包的时候webpack会给出一个warning，说加载不到这个外部资源，运行代码的时候会报错，提示没有这个模块。" target="_blank" rel="external">https://maps.googleapis.com/maps/api/js，打包的时候webpack会给出一个warning，说加载不到这个外部资源，运行代码的时候会报错，提示没有这个模块。</a></p>
<p>另外一个问题是，我需要if else判断，如果是中国的环境就加载中国域名的谷歌地图：<a href="http://ditu.google.cn/maps/api/js" target="_blank" rel="external">http://ditu.google.cn/maps/api/js</a> 否则就加载上面的，使用webpack是没办法做到的， 使用requireJs就可以很简单地直接require一下就行。</p>
<p>但其实这个问题很好解决只要自己写一个动态加载script的函数就好了，一个兼容性很好的版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function loadScript(url, callback)&#123;</div><div class="line">var script = document.createElement(&quot;script&quot;)</div><div class="line">script.type = &quot;text/javascript&quot;;</div><div class="line">if (script.readyState)&#123; //IE</div><div class="line">script.onreadystatechange = function()&#123;</div><div class="line">if (script.readyState == &quot;loaded&quot; || script.readyState == &quot;complete&quot;)&#123;</div><div class="line">script.onreadystatechange = null;</div><div class="line">callback();</div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">&#125; else &#123; //Others</div><div class="line">script.onload = function()&#123; callback(); &#125;;</div><div class="line">&#125;</div><div class="line">script.src = url;</div><div class="line">document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>详见： <a href="https://www.nczonline.net/blog/2009/07/28/the-best-way-to-load-external-javascript/" target="_blank" rel="external">The best way to load external JavaScript</a></p>
<p>webpack虽然是一个利器，但是坑也不少，目前遇到过的不太好解决的问题：</p>
<h2 id="遇到的困难"><a href="#遇到的困难" class="headerlink" title="遇到的困难"></a><strong>遇到的困难</strong></h2><h3 id="1-chunkhash"><a href="#1-chunkhash" class="headerlink" title="1. chunkhash"></a><strong>1. chunkhash</strong></h3><p>使用chunkhash有两个问题，一个是css改变之后，js的版本号也会跟着改变，即使js没有修改，但是比较这两个js文件的时候，你会发现这两个版本号不一样的文件内容是完全一模一样的。因为chunkhash不是根据文件内容算的hash值。第二个问题是，相同的代码在不同人的机器上打的包的版本号不一样。如果使用一些根据文件内容打版本号的插件，如 <a href="https://www.npmjs.com/package/webpack-md5-hash" target="_blank" rel="external">webpack-md5-hash</a> ，这个插件是用文件内容作一个md5的计算得出一个版本号，这样可以解决上面的两个问题，但是又引发了新的问题，这个md5的时不时就会出现打的版本号不唯一的情况，文件内容不同、版本号相同，而且这个概率还不小。所以最后还是放弃了使用这个插件，然后又尝试了另外一个使用sha算法计算，但是这个改了一个文件会使几个文件的版本号也发生变化。现在还是使用chunkhash</p>
<h3 id="2-模块id发生变化"><a href="#2-模块id发生变化" class="headerlink" title="2. 模块id发生变化"></a><strong>2. 模块id发生变化</strong></h3><p>上文提到，webpack的模块是用id标志的，每个模块对就一个id，例如util对应2，但是这个id不是固定不变的，在n次修改和打包之后，util的id可能会变成了3，这个就比较坑了，给增量上线造成了阻力，即单独上一个html有风险。因为在common-chunk里面，util的id是上次打包的时候定的，但是你这次打包util的id变了，而你只想上home.html，在home.html里面引的home.js里面使用到的util的id对不上common-chunk里面的，导致不能在home里面正常地加载util这个模块。一个临时的解决办法是，home.js不要使用common-chunk，所有的模块都打包到home.js里面就不会有这个问题。</p>
]]></content>
      
        
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用git命令]]></title>
      <url>/2016/05/02/%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h3 id="本地代码上传github"><a href="#本地代码上传github" class="headerlink" title="本地代码上传github"></a>本地代码上传github</h3><pre><code>git init
git add .
git commit -m &quot;first commit&quot;
git remote add origin git@github.com:simple7/blog.git
git push -u origin master
</code></pre><h3 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h3><pre><code># 在当前目录新建一个git代码库
git init

# 下载一个项目和它的整个历史
git clone [url]
</code></pre><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><pre><code># 列出所有分支
git branck -a

# 新建一个分支并切换到该分支
git checkout -b [branch]

# 合并指定分支到当前分支
git merge [branch]

# 新建一个分支，指向指定commit
git branch [branch] [commit]
</code></pre><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><pre><code># 列出所有tag
git tag

# 新建一个tag在当前commit
git tag [tag]

# 新建一个tag在指定commit
git tag [tag] [commit]

# 删除本地tag
git tag -d [tag]

# 删除远程tag
git push origin :refs/tags/[tagName]

# 查看tag信息
git show [tag]

# 提交指定tag
git push [remote] [tag]

# 提交所有tag
git push [remote] --tags

# 新建一个分支，指向某个tag
git checkout -b [branch] [tag]
</code></pre><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><pre><code># 显示有变更的文件
git status

# 显示当前分支的版本历史
git log

# 显示过去5次提交
git log -5 --pretty --oneline
</code></pre><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><pre><code># 下载远程仓库的所有变动
git fetch [remote]

# 取回远程仓库的变化，并与本地分支合并
git pull [remote] [branch]

# 上传本地指定分支到远程仓库
git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
git push [remote] --force

# 推送所有分支到远程仓库
git push [remote] --all
</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre><code># 生成一个可供发布的压缩包
git archive
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用的一些命令]]></title>
      <url>/2016/04/25/%E6%9C%AD%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="乱七八糟命令"><a href="#乱七八糟命令" class="headerlink" title="乱七八糟命令"></a>乱七八糟命令</h2><h3 id="1、安装cnpm-镜像服务器"><a href="#1、安装cnpm-镜像服务器" class="headerlink" title="1、安装cnpm 镜像服务器:"></a>1、安装<code>cnpm</code> 镜像服务器:</h3><pre><code>npm install -g cnpm --registry=https://registry.npm.taobao.org
</code></pre><h3 id="2、全局安装vue"><a href="#2、全局安装vue" class="headerlink" title="2、全局安装vue"></a>2、全局安装vue</h3><pre><code>cnpm install -g vue-cli
</code></pre><h3 id="3、设置npm代理"><a href="#3、设置npm代理" class="headerlink" title="3、设置npm代理"></a>3、设置npm代理</h3><pre><code>npm config set registry http://registry.cnpmjs.org
</code></pre><h3 id="4、启动mongodb"><a href="#4、启动mongodb" class="headerlink" title="4、启动mongodb"></a>4、启动mongodb</h3><pre><code># 控制台在mongodb安装路径的bin目录下
$ mongod --dbpath D:\Mongodb\data  
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> 随便记记 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
